/*-------------------------------------------------------------	mc.drawGear is a method that draws gears... you	know, cogs with teeth and a hole in the middle where	the axle goes? Okay, okay... so nobody *needs* a	method to draw a gear. I know that this is probably	one of my least useful methods. But it was an easy	adaptation of the polygon method so I did it anyway.	Enjoy. FYI: if you modify this to draw the hole	polygon in the opposite direction, it will remain	transparent if the gear is used for a mask.-------------------------------------------------------------*/MovieClip.prototype.drawGear = function(x, y, sides, innerRadius, outerRadius, angle, holeSides, holeRadius) {	// ==============	// mc.drawGear() - by Ric Ewing (ric@formequalsfunction.com) - version 1.3 - 3.5.2002	// 	// x, y = center of gear.	// sides = number of teeth on gear. (must be > 2)	// innerRadius = radius of the indent of the teeth.	// outerRadius = outer radius of the teeth.	// angle = [optional] starting angle in degrees. Defaults to 0.	// holeSides = [optional] draw a polygonal hole with this many sides (must be > 2)	// holeRadius = [optional] size of hole. Default = innerRadius/3.	// ==============	if(arguments<5) {		return;	}	if (sides>2) {		// init vars		var step, qtrStep, start, n, dx, dy;		// calculate length of sides		step = (Math.PI*2)/sides;		qtrStep = step/4;		// calculate starting angle in radians		start = (angle/180)*Math.PI;		this.moveTo(x+(Math.cos(start)*outerRadius), y-(Math.sin(start)*outerRadius));		// draw lines		for (n=1; n<=sides; n++) {			dx = x+Math.cos(start+(step*n)-(qtrStep*3))*innerRadius;			dy = y-Math.sin(start+(step*n)-(qtrStep*3))*innerRadius;			this.lineTo(dx, dy);			dx = x+Math.cos(start+(step*n)-(qtrStep*2))*innerRadius;			dy = y-Math.sin(start+(step*n)-(qtrStep*2))*innerRadius;			this.lineTo(dx, dy);			dx = x+Math.cos(start+(step*n)-qtrStep)*outerRadius;			dy = y-Math.sin(start+(step*n)-qtrStep)*outerRadius;			this.lineTo(dx, dy);			dx = x+Math.cos(start+(step*n))*outerRadius;			dy = y-Math.sin(start+(step*n))*outerRadius;			this.lineTo(dx, dy);		}		// This is complete overkill... but I had it done already. :)		if (holeSides>2) {			if(holeRadius == undefined) {				holeRadius = innerRadius/3;			}			step = (Math.PI*2)/holeSides;			this.moveTo(x+(Math.cos(start)*holeRadius), y-(Math.sin(start)*holeRadius));			for (n=1; n<=holeSides; n++) {				dx = x+Math.cos(start+(step*n))*holeRadius;				dy = y-Math.sin(start+(step*n))*holeRadius;				this.lineTo(dx, dy);			}		}	}};
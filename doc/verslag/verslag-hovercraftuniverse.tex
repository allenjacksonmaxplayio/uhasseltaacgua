 \documentclass[a4paper]{article}

%NOTE BY DIRK: 	Gelieve paragrafen gewoon in te typen, geen \par gedoe.
%								Citaties liefst in de vorm "author:1999" met author=achternaam van de eerste auteur
%								figuren, tabellen, listings, ... met prefixen: fig, tab, lst, ...


\author{Olivier Berghmans, Nick De Frangh, Dirk Delahaye,\\Kristof Overdulve, Pieter-Jan Pintens, Tobias Van Bladel}
\title{Architectuur en Algoritmen van Computer Games\\\textbf{Hovercraft Universe}\\\small{\url{http://uhasseltaacgua.googlecode.com/}}}
\pagestyle{plain}
\usepackage[dutch]{babel}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{url}
\usepackage{todonotes}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{listings}
\hypersetup{
%    bookmarks=true,         % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={Architectuur en Algoritmen van Computer Games},    % title
    pdfauthor={Olivier Berghmans, Nick De Frangh, Dirk Delahaye, Kristof Overdulve, Pieter-Jan Pintens, Tobias Van Bladel},     % author
    pdfsubject={Hovercraft Universe},   % subject of the document
    %pdfcreator={Creator},   % creator of the document
    %pdfproducer={Producer}, % producer of the document
    %pdfkeywords={keywords}, % list of keywords
    pdfnewwindow=true,      % links in new window
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=black,          % color of internal links
    citecolor=green,        % color of links to bibliography
    filecolor=magenta,      % color of file links
    urlcolor=cyan           % color of external links
}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introductie}
\emph{Hovercraft Universe} is een race game waarin spelers tussen planeten in de ruimte kunnen rondvliegen met hovercrafts.\todo{meer blabla:p}

\section{Gebruikte libraries}
%MAXIMUM 2 ZINNEN PER ENTRY!!!
\begin{itemize}
\item[\textbf{Physics}] De fysische gamewereld wordt gesimuleerd door Havok Physics\footnote{\url{http://www.havok.com/index.php?page=havok-physics}}. Havok draait enkel op de server en zorgt voor alle berekeningen die nodig zijn voor fysische interactie.

\item[\textbf{Rendering}] Voor het renderen gebruiken we de Ogre Open Source Graphics Engine\footnote{\url{http://www.ogre3d.org/}}. Ogre draait enkel op de clients en zorgt voor de visuele representatie van de game-entiteiten. Andere, uitsluitend visuele, effecten en overlays worden ook door Ogre afgehandeld: particle effects, tekst overlays boven de entiteiten, \ldots.

\item[\textbf{Netwerk}] ZoidCom\footnote{\url{http://www.zoidcom.com/}}

\item[\textbf{Input}] Object Oriented Input System (OIS)\footnote{\url{http://sourceforge.net/projects/wgois/}}

\item[\textbf{Geluid}] FMOD Interactive Audio Middelware\footnote{\url{http://www.fmod.org/}}

\item[\textbf{Scripting}] Lua\footnote{\url{http://www.lua.org/}} en LuaBind\footnote{\url{http://www.rasterbar.com/products/luabind.html}} bieden de mogelijkheid om op een dynamische manier eigenschappen van het spel te veranderen.

\item[\textbf{GUI}] Adobe Flash\footnote{\url{http://www.adobe.com/products/flash/}} en Hikari\footnote{\url{http://code.google.com/p/hikari-library/}}.
\end{itemize}

\section{Programmastructuur en -organisatie}
\subsection{Algemeen}
De basisstructuur van de engine achter Hovercraft Universe is gemaakt naar analogie met de architectuur van \emph{Shellshock: Nam '67} \cite{rouwe:2005}. Elk object in de spelwereld waarmee ge\"interageerd kan worden, wordt voorgesteld door een \texttt{Entity}. Deze entiteiten worden gegroepeerd in de \texttt{EntityManager}, die de entiteiten tijdens het spel kan updaten. In onze implementatie is een \texttt{Entity} tevens een uitbreiding van \texttt{NetworkEntity}, die replicatie over het netwerk mogelijk maakt.

Entiteiten kunnen bestuurd worden door \texttt{Controller}s. Een controller generereert \emph{events}, die door de entiteiten gepolld worden. Deze interface laat toe om entiteiten te besturen op verschillende manieren: toetsenbord/muis, AI, \ldots.

Voor de visuele representatie op de clients heeft elke relevante entiteit een \texttt{EntityRepresentation}. Deze verbindt de conceptuele entiteit met een entiteit in Ogre. Om de wereld te kunnen tekenen vanuit het standpunt van \'e\'en speler worden deze representatie-objecten, samen met de Ogre camera, bijgehouden in een \texttt{GameView}. 

De bovenstaande klassen zitten vervat binnen het \texttt{CoreEngine}-project, dat in principe voor eender welk soort spel gebruikt kan worden. Voor Hovercraft Universe is een specifieke implementatie voorzien: de \texttt{HovercraftController}, waarvan de \texttt{HovercraftAIController} en \texttt{HovercraftPlayerController} afgeleid worden. 

\todo{Iets over de application / server application structuur}

\subsection{Netwerkstructuur}

%\begin{figure}
%	\centering
%		\includegraphics[width=0.50\textwidth]{images/netwerkfreq.png}
%	\caption{The client entity polls its next move from the controller}
%	\label{fig:netwerkfreq}
%\end{figure}
%
%\begin{figure}
%	\centering
%		\includegraphics[width=0.50\textwidth]{images/zoidcom.png}
%	\caption{ZoidCom werking}
%	\label{fig:zoidcom}
%\end{figure}
\todo{Server, client, netwerk, zoidcom, chatfunctionaliteit, replicatie, interpolatie, ....}

\todo{Olivier!}


\subsection{Modellen en user-data}
De \textbf{modellen} zijn gedefinieerd in het (niet open) bestandsformaat van 3DS Max. Deze worden ge\"exporteerd naar het DotScene XML-formaat met behulp van de OgreMax Scene Exporter\footnote{\url{http://www.ogremax.com/}}. DotScene\footnote{\url{http://www.ogre3d.org/wiki/index.php/DotScene}} is een gestandaardiseerd XML-formaat dat informatie bevat over het soort entiteit, de grootte van het model, de gebruikte materialen en meshfiles, etc. Tevens bevat dit DotScene bestand informatie specifiek voor gebruik in HovercraftUniverse (snelheid, gewicht, \ldots). Een voorbeeld van deze user-data is gegeven in Listing~\ref{lst:sceneuserdata}.

\lstset{language=XML,caption=UserData in DotScene,label=lst:sceneuserdata}
\begin{lstlisting}
<Hovercraft>
    <Name>hover1</Name>
    <Description>Nonw</Description>
    <OgreEntity>hover1</OgreEntity>
    <ProcessInterval>0.016</ProcessInterval>
    <Speed>100</Speed>
    <Mass>50</Mass>
    <Acceleration>10</Acceleration>
    <Steering>100</Steering>
</Hovercraft>
\end{lstlisting}

Voor de \textbf{mappen} (tracks) wordt er \'e\'en groot DotScene wereld gegenereerd waarin alle relevante nodes zijn gedefinieerd: planeten, checkpoints, statische objecten, startposities, etc. Een voorbeeld van een dergelijke node is te zien in Listing~\ref{lst:jumpnode}

\lstset{language=XML,caption=E\'en van de nodes in de DotScene van een wereld.,label=lst:jumpnode}
\begin{lstlisting}
<node name="Jump01">
    <position x="-148.891" y="21.0134" z="-20.245" />
    <scale x="1" y="1" z="1" />
    <rotation qx="0.13454" qy="0.990908" 
        qz="-5.34715e-008" qw="-7.48115e-008" />
    <entity name="Jump01" castShadows="true" receiveShadows="true" meshFile="Jump01.mesh">
        <userData>
            <![CDATA[<OgreEntity><GameEntity>Jump01_ent</GameEntity></OgreEntity>]]>
        </userData>
        <subentities>
            <subentity index="0" materialName="Jump02" />
        </subentities>
    </entity>
</node>
\end{lstlisting}

\subsection{Visualisatie en Ogre}
De \texttt{EntityRepresentation} klasse zorgt ervoor dat Ogre de verschillende entiteiten kan visualiseren.\todo{meer hierover}

Ook worden hier een aantal visuele effecten aan toegevoegd. Ogre Particle Systems worden gebruikt om rook, vonken, etc. weer te geven. Er is tevens een tekst-overlay voor de nicknames voorzien zodat de spelers elkaar kunnen herkennen tijdens het spel. Aangezien deze effecten enkel client-side gebeuren bij het tekenen van de entiteiten, heeft dit geen invloed op de performantie van de netwerkcomponenten.

\subsection{Physics}
\todo{PJ / Tobias}

\todo{Havok, draait enkel op server in aparte thread, ... binding tussen physics en de rest van het spel}

\todo{iets over krachten? }


\subsection{Grafische userinterface}
De onderdelen van de GUI zijn ge\"implementeerd in ActionScript\footnote{\url{http://www.adobe.com/devnet/actionscript/}}, en worden met behulp van Hikari gevisualiseerd in Ogre. Hikari is een library die Flash (SWF) bestanden kan inlezen, en voor de binding tussen Flash en C++ zorgt.

\todo{Nick}

\subsection{Geluid}
\todo{iets over FMod bestanden en hoe het werkt}

\todo{Iets over de 3D emitter...}

\todo{...Nick?}

\subsection{Besturing}
De centrale klasse voor de besturing is de \texttt{KeyManager}. In deze klasse kunnen alle nodige acties geregistreerd worden door middel van een uniek ID, bijvoorbeeld in een enumeratie. Aan elk van deze acties kunnen \'e\'en of meerdere knoppen gebonden worden. Telkens wanneer de \texttt{HovercraftPlayerController} een key event binnenkrijgt, zal er bij de key manager nagegaan worden welke actie er overeenkomt met deze toets. Op deze manier is het mogelijk om de spelbesturing gemakkelijk te wijzigen zonder dat de controller aangepast moet worden. Bovendien kunnen er meerdere toetsen voor dezelfde actie gebruikt worden.

In de \texttt{KeyManager} staat ook nog een mapping tussen alle toetsen die OIS ondersteunt en hun bijhorende string-representatie. Zo kunnen de controls ingelezen of weggeschreven worden naar een configuratiebestand. Standaard is dit bestand te vinden in de data\textbackslash controls map, maar wanneer dit bestand ontbreekt zal er automatisch een nieuw aangemaakt worden met de default controls. In dit configuratiebestand staan alle geregistreerde acties per categorie. Voor elke actie kunnen \'e\'en of meerdere toetsen opgegeven worden, gescheiden door een komma. Wanneer een actie ontbreekt, zal de standaardtoets voor deze actie gebruikt worden.

\subsection{Scripting en AI}
Voor de bots is een AI voorzien, die ``menselijk'' stuurgedrag nabootst. De algoritmen van deze AI zijn gebaseerd op de autonome stuursimulaties van Craig Reynolds \cite{reynolds:1999}. De huidige AI is in staat om een voorgedefinieerd pad te volgen binnen een bepaalde marge (``Path Following''). Een pad wordt voorgesteld als een \emph{multiline}: een lijst van punten in de wereld, telkens geassocieerd met een straal (\texttt{radius}). De straal op punt $x_i$ stelt de \emph{breedte} van het pad voor tussen punt $x_i$ e, $x_{i+1}$. Deze paden worden opgeslagen in aparte bestanden. Dit betekent dat de level designers per map een ideaal pad (of meerdere paden) voor de AI kunnen aanmaken. 

De AI is geprogrammeerd in Lua \cite{lerusalimschy:2006}, om aanpassing van de AI-algoritmen mogelijk te maken zonder dat het spel hiervoor gehercompileerd moet worden. Voor de binding tussen Lua en C++ wordt Luabind gebruikt. De \texttt{ScriptWrapper} klasse abstraheert deze scripts en laat de programmeurs toe om met de scripts te werken, zonder Lua-specifieke constructies te moeten gebruiken.

\emph{Collision avoidance} voor de AI is ook ge\"implementeerd met behulp van Havok physics. Er zijn twee implementaties beschikbaar voor de \texttt{EntityCollision} interface. Het eenvoudige model (zie Figuur~\ref{fig:simplecollisionavoidance}) plaatst een kubus op een bepaalde afstand van het voertuig om objecten te detecteren. Dit model gebruikt zeer weinig resources, maar is ook niet zo krachtig. Het geavanceerde model gebruikt een 3D-lichaam dat zich uitstrekt van het voertuig tot de gewenste afstand voor de figuur (zie Figuur~\ref{fig:advancedcollisionavoidance}). Deze manier van werken heeft een kleine meerkost in resources in vergelijking met het eenvoudige model.

Aangezien deze methodes afhankelijk zijn van de physics, draaien ze op de server. Als een object wordt gedetecteerd, wordt dit door middel van een event doorgegeven aan een callback functie in de entiteit. Dit wordt vertaald naar een boolean in de entiteit, die door het netwerk wordt gerepliceerd op de client. Client-side maakt de AI dan een beslissing om het obstakel te ontwijken.

\begin{figure}%
\begin{center}
\includegraphics[width=0.6 \columnwidth]{images/collision_prevention_simple.jpg}%
\end{center}
\caption{Het eenvoudige collision avoidance model}%
\label{fig:simplecollisionavoidance}%
\end{figure}

\begin{figure}%
\begin{center}
\includegraphics[width=0.8 \columnwidth]{images/collision_prevention_advanced.jpg}%
\end{center}
\caption{Het geavanceerde collision avoidance model}%
\label{fig:advancedcollisionavoidance}%
\end{figure}

\subsection{Game Logic}
\todo{Lobby, admins? of bij netwerken}

\todo{Raceplayer, Racestate, positiebepaling}

\subsection{Level of Detail}
\subsubsection{Netwerk}
\todo{update rate afhankelijk van de afstand tussen A en B, ...}

\subsubsection{Rendering}
\todo{Polycount verminderen afhankelijk van de afstand van het te tekenen object met ogre...}

\subsection{Misc.}

\subsubsection{Configuratiebestanden}
Configuratiebestanden zijn beschikbaar voor de server en client, in INI formaat (zie Listing~\ref{lst:inifileformat}). Dit laat gebruikers toe om hun nickname, gekozen voertuig, enz. te kiezen en op te slaan. Een aantal server-specifieke instellingen worden ook ondersteund (aantal spelers, AI-script, sterkte van de zwaartekracht, \ldots). Het spel kan deze bestanden ook opslaan met de huidige instellingen.

\lstset{caption=Het INI bestandsformaat,label=lst:inifileformat}
\begin{lstlisting}
[section name]
keyname=value
#comment
keyname = value, value , value #comment
\end{lstlisting}

\section{Rolverdeling en verantwoordelijkheden}\todo{dit erin houden?}
\begin{description}
	\item[Kristof Overdulve] Algemene architectuur, 3D modellering, Ogre visualisatie en animatie
	\item[Pieter-Jan Pintens] Havok Physics, 3D modellering, Ogre visualisatie en animatie
	\item[Dirk Delahaye] Scripting, AI, visuele effecten, configuratiebestanden
	\item[Tobias Van Bladel] Input, controls, physics
	\item[Nick De Frangh] Grafische user interface, Geluid
	\item[Olivier Berghmans] Algemene architectuur, netwerk
\end{description}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
